
- name: Ensure Django app directory exists # make sure required directories are available for the Django app and its virtual environment before any other operations.
  file: # ansible module to manage files and directories
    path: "{{ django_app_dir }}"
    state: directory # we want a directory to exist at this path
    owner: admin  # Replace with your server username
    mode: '0755' # meaning the owner has full permissions, and others have read and execute permissions

- name: Ensure Django virtual environment directory exists
  file:
    path: "{{ django_venv_dir }}"
    state: directory
    owner: admin  # Replace with your server username
    mode: '0755'

- name: Clone entire repository
  git:
    repo: 'https://github.com/Medkhaled1/django_project.git'
    dest: "{{ django_app_dir }}"
    version: 'main'
    force: yes
  register: git_clone
  ignore_errors: yes
- debug:
    var: git_clone

- name: Install Python dependencies for Django # install the necessary Python dependencies for running a Django application and for connecting it to a PostgreSQL database.
  pip: # installs Python packages in the specified virtual environment
    name: # Lists packages to install
      - gunicorn
      - django
      - psycopg2
    virtualenv: "{{ django_venv_dir }}" # the path to the virtual environment where the packages will be installed
    virtualenv_site_packages: no # ensures the virtual environment does not use global site packages.
    state: present # package should be installed if it’s not already present

- name: Configure Django settings # Copies settings.py.j2 template to the Django application directory and applies environment-specific configurations
  template:
    src: settings.py.j2
    dest: "{{ django_app_dir }}/django/mysite/settings.py" # Updated path for settings.py in the cloned repository
    owner: admin # Replace with server username
    mode: '0644' # Read/write permissions for the owner; read-only for others

- name: Migrate Django Database # Apply database migrations for Django, creating tables and fields as defined in the Django models.
  command: "{{ django_venv_dir }}/bin/python {{ django_app_dir }}/django/manage.py migrate" # Updated path for manage.py
  args:
    chdir: "{{ django_app_dir }}/django/mysite" # Ensure you're in the correct app directory for migrations

- name: Collect Static Files # Prepare the Django app’s static files for use in production.
  command: "{{ django_venv_dir }}/bin/python {{ django_app_dir }}/django/manage.py collectstatic --noinput" # Updated path for manage.py
  args:
    chdir: "{{ django_app_dir }}/django/mysite" # Ensure you're in the correct app directory for collecting static files

- name: Deploy Gunicorn systemd service # set up a systemd service for managing the Django application with Gunicorn, allowing it to start, stop, and restart automatically.
  template: # The template module copies and customizes files from your Ansible control machine to the target machine, based on a Jinja2 template (django.service.j2)
    src: gunicorn.service.j2 # Path to the local template file (django.service.j2), which defines how to run Django using Gunicorn.
    dest: /etc/systemd/system/gunicorn.service # Path on the remote server where the configured service file will be copied.
  notify: Reload systemd # after changes , restart Django handler will be notified

- name: Enable Gunicorn service # enable and start the Django application as a systemd service, so it will run continuously and automatically restart if the server reboots.
  systemd: # The systemd module manages systemd services on Linux.
    name: gunicorn # Name of the service (django), as specified in the service file created in the previous step.
    enabled: yes # ensures the service starts on boot.
    state: started # starts the service immediately.

- name: Reload systemd to pick up Gunicorn service file
  become: true
  ansible.builtin.command: systemctl daemon-reload

- name: Check Gunicorn service status
  become: true
  ansible.builtin.systemd:
    name: gunicorn
    enabled: yes
    state: started

- name: Verify Django application deployment
  uri:
    url: "http://localhost"  # Replace with your server's address and port if necessary
    return_content: yes
    status_code: 200  # Expect a 200 OK response
  register: result

- name: Display Django application response
  debug:
    var: result.content
  when: result.status == 200  # Display content only if the response is 200 OK